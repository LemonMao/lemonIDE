#!/usr/bin/python3
from __future__ import print_function

import argparse
import os, time
import re
import signal
import socket
import subprocess
from operator import itemgetter
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from threading import Timer

HOME = os.getenv('HOME', None)

SSH_HOSTS = HOME + "/.sshhosts"
MAX_HOST_LEN = 50
MAX_NAME_LEN = 30

def bold_green_fmt(value):
    return "\033[1m\033[32m{0}\033[m".format(value)

def bold_cyan_fmt(value):
    return "\033[1m\033[36m{0}\033[m".format(value)

def bold_fmt(value):
    return "\033[1m{0}\033[m".format(value)

def bold_red_fmt(value):
    return "\033[1m\033[31m{0}\033[m".format(value)

def red_fmt(value):
    return "\033[31m{0}\033[m".format(value)

def error_msg(msg):
    print("{0} {1}".format(bold_red_fmt("Error:"), red_fmt(msg)))

def is_wildcard(pattern):
  """
  This function checks if a string is likely a shell wildcard pattern.
  """
  wildcards = "*?"
  # Check for presence of wildcard characters
  if any(char in wildcards for char in pattern):
    return True
  # Handle cases like ".bashrc" (not a wildcard)
  if pattern.startswith(".") and not pattern.startswith(".*"):
    return False

  # Consider patterns with escaped characters (not reliable)
  # This is a simplified approach and might not capture all edge cases.
  escape_chars = "\\"
  if any(char in escape_chars for char in pattern):
    return False

  return False

def get_customed_machines():
    """Get list of remote servers from file ~/.sshhosts
    #cat ~/.sshhosts
    10.224.38.228                          Test manager
    qavm01.prod.sea1.west.isilon.com       Sea1 qaVM
    """
    # if SSH_HOSTS file not exist or empty, create it.
    # And write the example above to it.
    if not os.path.exists(SSH_HOSTS) or os.stat(SSH_HOSTS).st_size == 0:
        with open(SSH_HOSTS, "w") as hostfile:
            host_spaces = " " * (MAX_HOST_LEN - 1)
            hostfile.write(
                    "# Start with '#' will be considered as comment.\n#\n"
                    "# IPs(<user>@<ip/domain>)                   Machine name(no space in name)            Information of machine(can include space)\n#\n"
                    "#  2.2.2.2,lmao@1.1.1.1                           my_server                                 Test server\n"
                    "#  lmao@test.lemon.com                            isi_debug                                 Sea1 qaVM\n"
            )

    hosts = []
    # print("hosts file:{0}".format(SSH_HOSTS))
    with open(SSH_HOSTS, "r") as hostfile:
        i = 0
        for line in hostfile.readlines():
            # if line is start with '#' or empty line, continue
            if line.startswith('#') or not line.strip():
                continue
            host = {}
            host["id"] = i
            i += 1
            host["ips"] = line.split(' ', 1)[0].split(',', 1)
            host["name"] = line.split(' ', 1)[1].strip().split(' ', 1)[0]
            host["location"] = line.split(' ', 1)[1].strip().split(' ', 1)[1].strip()
            host["build"] = 'N/A'
            hosts.append(host)

    return hosts

def choose_cluster_ip(cluster, ip=None):
    """Choose the ducttape IP to use."""
    if ip is None:
        if not cluster["ips"]:
            error_msg("Cluster: {0} does not have any IPs".format(cluster["name"]))
            return None
        ip = cluster["ips"][0]
    return ip

def get_machine_ip(target=None, just_print=False):
    """Get the node IP to use for the cross compiler."""
    idx_wrap = [0]

    def get_digits(num):
        digits = 1
        num = num // 10
        while num != 0:
            digits += 1
            num = num // 10
        return digits

    def next_num():
        idx_wrap[0] += 1
        return idx_wrap[0]

    def current_num():
        return idx_wrap[0]

    idx_to_machine = {}
    name_to_machine = {}
    all_machines = {}

    all_machines["Servers"] = get_customed_machines()

    for typestr, servers in all_machines.items():
        # type string
        print("# {0}:\n".format(typestr))
        servers= sorted(servers, key=itemgetter("id"))
        for vm in servers:
            # Always assign a number for the machine
            machine_num = next_num()
            if not target:
                print("  ({0}) {1}".format(bold_green_fmt(machine_num), vm["name"]))
            idx_to_machine[machine_num] = { "machine": vm }
            # For name lookup, point to the machine entry (without IP)
            name_to_machine[vm["name"]] = idx_to_machine[machine_num]

            # vm info - location, build
            spaces = " " * get_digits(machine_num)
            if vm["location"] and not target:
                print("     {2}Info: {0}  --  {1}".format(
                    vm["location"], vm["build"], spaces))

            # Always assign numbers for IPs
            ip_nums = []
            for ip in vm["ips"]:
                ip_num = next_num()
                ip_nums.append(ip_num)
                idx_to_machine[ip_num] = { "machine": vm, "ip": ip }
                # Note: we are not updating name_to_machine with IPs for the same machine name
                # This preserves the original behavior where name lookup returns the machine entry

            if not target:
                print("     {1}IPs:      {0}".format(
                    ", ".join(["({0}) {1}".format(bold_cyan_fmt(ip_num), ip) for ip_num, ip in zip(ip_nums, vm["ips"])])
                    , spaces))
                print("")

    if just_print:
        exit(0)

    # Interactive selection if no target specified or target was invalid
    while True:
        answer = target if target else input(
            "Enter a Number or Name or <user@ip> of target: ").strip()

        # Handle user@ip format directly
        if '@' in answer:
            add_custom_host(answer)
            return answer

        try:
            info = None
            if answer.isnumeric():
                idx = int(answer, 10)
                info = idx_to_machine[idx]
            else:
                info = name_to_machine[answer]

            # Print information only for the specified target
            if target:
                vm = info["machine"]
                print("-------------------------")
                print("Machine: {0}".format(bold_green_fmt(vm["name"])))
                if vm["location"]:
                    print("Info: {0}  --  {1}".format(vm["location"], vm["build"]))
                print("IPs: {0}".format(", ".join(vm["ips"])))
                print("-------------------------")

            ip = choose_cluster_ip(info["machine"], ip=info.get("ip"))
            if ip:
                return ip
        except (ValueError, KeyError) as e:
            error_msg(f"'{answer}' is not a valid number. Please enter a number, machine name, or user@ip. Details: {e}")
            if target:
                exit(-1)

def add_custom_host(host):
    """ if host exists, find if it exist in SSH_HOSTS file, if not add it. """
    servers = get_customed_machines()
    found = False
    for server in servers:
        if host in server["ips"]:
            found = True
            break
    if not found:
        name = input("Provide the machine name: ").strip()
        info = input("Provide the machine info: ").strip()
        print(f"info:{info}")
        info = "N/A" if not info else info
        with open(SSH_HOSTS, "a+") as hostfile:
            space1 = " " * (MAX_HOST_LEN - len(host))
            space2 = " " * (MAX_NAME_LEN - len(name))
            hostfile.write(host + space1 + name + space2 + info + "\n")

def do_sftp(ip, user, path):
    if path == "lmao_sftp_prompt":
        path = input("SFTP path: ").strip()
    cmd = f"sftp {user}@{ip}:{path}"
    print(f"Perform SFTP: {cmd}")
    os.system(cmd)

def need_passwd(error_msg):
    need_pass_err = ["Permission denied (publickey,password,hostbased).", "Too many authentication failures"]
    for need_pass in need_pass_err:
        if need_pass in error_msg:
            return True
    return False

def need_clean_host_id(error_msg):
    need_clean_err = ["WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!"]
    for need_clean in need_clean_err:
        if need_clean in error_msg:
            return True
    return False

def do_rsync_monitor(ip, username, local_obj=None):
    """
    Monitors the directory/file changes and performs rsync with the remote server.
    """
    remote_obj = None
    if local_obj == "lmao_rsync_prompt":
        local_obj = input("Local target: ").strip()
    else:
        obj = os.getcwd() if not local_obj else local_obj
        if ":" in obj:
            obj = obj.split(':')
            local_obj = obj[0]
            remote_obj = obj[1] if obj[1] else None

    if os.path.isdir(local_obj) and (not local_obj.endswith('/')):
        local_obj += '/'
    if not is_wildcard(local_obj) and not os.path.exists(local_obj):
        error_msg(f"Local target {local_obj} does not exist")
        exit(1)

    if remote_obj is None:
        remote_obj = input("Remote target: ").strip()

    if os.path.isdir(local_obj) or is_wildcard(local_obj):
        remote_obj = f"{username}@{ip}:{remote_obj}"
    else:
        filename = local_obj.split('/')[-1]
        remote_obj = f"{username}@{ip}:{remote_obj}/{filename}"

    print(f"Keep sync for {local_obj} --> {remote_obj}\n")

    class ChangeEventHandler(FileSystemEventHandler):
        def __init__(self):
            self.sync_timer = None
            self.delay_ms = 500 / 1000
            self.queued_event = False

        def _do_sync(self):
            try:
                print(f"Target change detected. Syncing...\n"
                      f" \\_ {local_obj} ===> {remote_obj}")
                ret = subprocess.run(["rsync", "-a", local_obj, remote_obj])
                print(f" \\_ Complete syncing. Return:{ret.returncode}\n")
            except subprocess.CalledProcessError as e:
                print(f" \\_ Error syncing: {e} \n")
            finally:
                self.sync_timer.cancel()
                self.sync_timer = None

        def on_any_event(self, event):
            if not event.is_directory:
                return None
            if not self.sync_timer:
                print(f"File change detected: {event.src_path}. Make timer...")
                self.sync_timer = Timer(self.delay_ms, self._do_sync)
                self.sync_timer.start()

    # Example usage
    observer = Observer()
    observer.schedule(ChangeEventHandler(), os.path.dirname(local_obj), recursive=True)
    observer.start()
    try:
      while True:
          time.sleep(600)
    except KeyboardInterrupt:
        print("Stopping observer...")
        observer.stop()
    observer.join()

def do_rsync_direct(ip, username, local_obj=None):
    """
    Monitors the directory/file changes and performs rsync with the remote server.
    """
    remote_obj = None
    if local_obj == "lmao_rsync_prompt":
        local_obj = input("Local target: ").strip()
    else:
        obj = os.getcwd() if not local_obj else local_obj
        if ":" in obj:
            obj = obj.split(':')
            local_obj = obj[0]
            remote_obj = obj[1] if obj[1] else None

    if os.path.isdir(local_obj) and (not local_obj.endswith('/')):
        local_obj += '/'
    if not is_wildcard(local_obj) and not os.path.exists(local_obj):
        error_msg(f"Local target {local_obj} does not exist")
        exit(1)

    if remote_obj is None:
        remote_obj = input("Remote target: ").strip()

    if os.path.isdir(local_obj) or is_wildcard(local_obj):
        remote_obj = f"{username}@{ip}:{remote_obj}"
    else:
        filename = local_obj.split('/')[-1]
        remote_obj = f"{username}@{ip}:{remote_obj}/{filename}"

    print(f"Doing sync for {local_obj} --> {remote_obj}\n")

    try:
        ret = subprocess.run(["rsync", "-a", remote_obj, local_obj])
        print(f" \\_ Complete syncing. Return:{ret.returncode}\n")
    except subprocess.CalledProcessError as e:
        print(f" \\_ Error syncing: {e} \n")

def do_ssh(ip, username, passwordless):
    # print("Perform SSH clean! ", cmd2) -- "ssh-keygen -f ~/.ssh/known_hosts -R " + ip
    # Do ssh passwordless login
    print(f"Prepare to login to {username}@{ip}.")
    ssh_cmd = f"ssh -o StrictHostKeyChecking=no {username}@{ip}"
    passwdless_cmd = f"ssh-copy-id {username}@{ip} && {ssh_cmd}"
    if passwordless:
        result = subprocess.run(passwdless_cmd, shell=True, stderr=subprocess.PIPE)
    else:
        result = subprocess.run(ssh_cmd, shell=True, stderr=subprocess.PIPE)
        if result.returncode != 0 and result.stderr and need_passwd(result.stderr.decode('utf-8')):
            print("Password still required. Perform no-password login. ")
            subprocess.run(passwdless_cmd, shell=True, stderr=subprocess.PIPE)

    if result.stderr and need_clean_host_id(result.stderr.decode('utf-8')):
        print(f"Clean up known host ID for {ip}.")
        known_hosts_path = "~/.ssh/known_hosts"
        clean_cmd = f"ssh-keygen -f {known_hosts_path} -R {ip}"
        subprocess.run(clean_cmd, shell=True, stderr=subprocess.PIPE)

    print(f"Stderr:\n {result.stderr.decode('utf-8')}" if result.stderr else "\nGood Bye !!!\n")

def do_pull(ip, username, remote_path, local_path):
    """Pull files from remote to local using rsync"""
    # Prompt for remote path if not provided
    if remote_path is None:
        remote_path = input("Remote path to pull: ").strip()
    
    if local_path is None:
        local_path = input("Local path to save to [default: current directory]: ").strip()
        if not local_path:
            local_path = "."

    print(f"Pulling from {username}@{ip}:{remote_path} to {local_path}")

    # Build rsync command
    remote_spec = f"{username}@{ip}:{remote_path}"
    cmd = ["rsync", "-av", "--progress", remote_spec, local_path]

    try:
        result = subprocess.run(cmd)
        if result.returncode != 0:
            error_msg(f"rsync failed with return code {result.returncode}")
    except Exception as e:
        error_msg(f"Error during pull: {e}")


def do_push(ip, username, local_path, remote_path):
    """Push files from local to remote using rsync"""
    # Prompt for local path if not provided
    if local_path is None:
        local_path = input("Local path to push: ").strip()
    
    if not os.path.exists(local_path):
        error_msg(f"Local path {local_path} does not exist")
        exit(1)

    if remote_path is None:
        remote_path = input("Remote path to save to [default: current directory]: ").strip()
        if not remote_path:
            remote_path = "."

    print(f"Pushing from {local_path} to {username}@{ip}:{remote_path}")

    # Build rsync command
    remote_spec = f"{username}@{ip}:{remote_path}"
    cmd = ["rsync", "-av", "--progress", local_path, remote_spec]

    try:
        result = subprocess.run(cmd)
        if result.returncode != 0:
            error_msg(f"rsync failed with return code {result.returncode}")
    except Exception as e:
        error_msg(f"Error during push: {e}")

def exit_signal(signum, frame):
    exit(1)

def parse_ip_and_user(args):
    """Parse IP and username from arguments using the same logic for all commands"""

    # Get IP using the appropriate method
    ip = get_machine_ip(args.t, args.l)

    # Parse username from IP or use default
    username = ip.split("@")[0] if "@" in ip else "root"
    ip = ip.split("@")[1] if "@" in ip else ip

    # Handle username prompt if needed
    if hasattr(args, 'u'):
        if args.u == "lmao_prompt":
            username_input = input("Please choose the username: [Lmao|Root|other]: ").strip()
            if username_input == "l" or username_input == "L":
                username = "lmao"
            elif username_input == "r" or username_input == "R" or username_input == "":
                username = "root"
            else:
                username = username_input
        elif args.u != "lmao_no_prompt":
            username = args.u

    return ip, username

def main():
    signal.signal(signal.SIGINT, exit_signal)

    parser = argparse.ArgumentParser(description="Lemon SSH terminal tool")
    parser.add_argument("-t", type=str, default=None,
                        help="Target machine. Could be name or number.")
    parser.add_argument("-u", nargs="?", const='lmao_prompt', default="lmao_no_prompt",
                        help="Provide the user name to login.")
    parser.add_argument("-s", action="store_true", default=False,
                        help="Print the current SSH processes.")
    parser.add_argument("-l", action="store_true", default=False,
                        help="Print the remote servers list.")
    parser.add_argument("-p", action="store_true", default=False,
                        help="Perform passwordless login.")

    subparsers = parser.add_subparsers(dest='command', help='sub-command help')

    # parser for sftp command
    parser_sftp = subparsers.add_parser('sftp', help='Perform SFTP to a remote server')
    parser_sftp.add_argument("path", nargs="?", default='lmao_sftp_prompt', help="SFTP path")

    # parser for rsync-monitor command
    parser_rsync_monitor = subparsers.add_parser('sync', help='Monitor and sync local changes to remote')
    parser_rsync_monitor.add_argument("path", nargs="?", default='lmao_rsync_prompt',
                        help="Local and remote path specification. E.g. \"local_obj:remote_obj\"")

    # parser for pull command
    parser_pull = subparsers.add_parser('pull', help='Pull files from remote')
    parser_pull.add_argument("remote_path", nargs="?", help="Remote file/directory path to pull")
    parser_pull.add_argument("local_path", nargs="?", help="Local path to save to (default: current directory)")

    # parser for push command
    parser_push = subparsers.add_parser('push', help='Push files to remote')
    parser_push.add_argument("local_path", nargs="?", help="Local file/directory path to push")
    parser_push.add_argument("remote_path", nargs="?", help="Remote path to save to")

    args = parser.parse_args()

    # Set default command to connect if no subcommand provided
    if not args.command:
        args.command = 'connect'

    # print the current ssh processes and exit
    if args.s is True:
        os.system("ps axjf | grep -v 'grep' | grep 'python.*mssh' -A2")
        return

    ip, username = parse_ip_and_user(args)
    if args.command == 'connect':
        do_ssh(ip, username, args.p)
    elif args.command == 'sftp':
        do_sftp(ip, username, args.path)
    elif args.command == 'sync':
        do_rsync_monitor(ip, username, args.path)
    elif args.command == 'pull':
        do_pull(ip, username, args.remote_path, args.local_path)
    elif args.command == 'push':
        do_push(ip, username, args.local_path, args.remote_path)

    return

if __name__ == "__main__":
    exit(main())
